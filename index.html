<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Traffic Management and Disaster Impact</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #eef2f3;
            color: #333;
        }
        h1 {
            color: #ffffff;
            background: #2c3e50;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            margin-top: 50px;
        }
        h2, h3 {
            color: #2c3e50;
        }
        #instructions {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2em;
            background: #d6eaf8;
            padding: 15px;
            border: 1px solid #aed6f1;
            border-radius: 10px;
        }
        #details {
            display: none;
            margin-top: 20px;
        }
        .section {
            background: #ffffff;
            border: 1px solid #d5d8dc;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        ul {
            list-style-type: square;
            margin-left: 20px;
        }
        footer {
            text-align: center;
            margin-top: 20px;
            font-size: 0.9em;
            color: #555;
        }
        pre {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #dcdcdc;
            overflow-x: auto;
        }
    </style>
    <script>
        function toggleDetails(id) {
            const details = document.getElementById(id);
            details.style.display = details.style.display === 'none' ? 'block' : 'none';
        }
    </script>
</head>
<body>
    <div id="instructions">
        <p>Click on the business cases to know about them..</p>
    </div>

    <h1 onclick="toggleDetails('trafficDetails')">Smart Traffic Management System</h1>
    <div id="trafficDetails" style="display: none;">
        <div class="section">
            <h2>Smart Traffic Management Systems</h2>
            <p>Target 11.7: Provide Access to Safe and Inclusive Green and Public Spaces</p>
            <p><strong>Target:</strong> By 2030, provide universal access to safe, inclusive, and accessible, green and public spaces, particularly for women and children, older persons, and persons with disabilities.</p>
        </div>
        <div class="section">
            <h3>Indicators</h3>
            <ul>
                <li><strong>Indicator 11.7.1:</strong> Average share of the built-up area of cities that is open space for public use for all, by sex, age, and persons with disabilities.</li>
                <li><strong>Indicator 11.7.2:</strong> Proportion of persons victimized by physical or sexual harassment, by sex, age, disability status, and place of occurrence, in the previous 12 months.</li>
            </ul>
        </div>
        <div class="section">
            <h3>Examples</h3>
            <p>Smart Traffic Management can include:</p>
            <ul>
                <li>Adaptive traffic signal systems that respond to real-time congestion.</li>
                <li>Integration of green corridors to reduce pollution and enhance public spaces.</li>
                <li>Advanced route planning for emergency and public transport vehicles.</li>
            </ul>
        </div>
        <div class="section">
            <h3>Advantages</h3>
            <ul>
                <li><strong>Cost Efficiency:</strong> Reduces fuel consumption and operational costs by minimizing congestion.</li>
                <li><strong>Improved Traffic Flow:</strong> Decreases bottlenecks and enhances movement across the network.</li>
                <li><strong>Scalability:</strong> Effective in both small and large cities, adapting as urban areas grow.</li>
                <li><strong>Safety:</strong> Enhances road safety and reduces accidents through optimized systems.</li>
            </ul>
        </div>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Traffic Management Case Study with C++ Code</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 40px;
            background-color: #f4f4f9;
        }
        h1, h2 {
            color: #333;
        }
        .section {
            margin-bottom: 20px;
        }
        .solution {
            background-color: #e9f7ef;
            padding: 15px;
            border-left: 4px solid #2ecc71;
        }
        .example {
            background-color: #f9f9f9;
            border-left: 4px solid #3498db;
            padding: 10px;
            margin-top: 10px;
        }
        .algorithm {
            background-color: #f8d7da;
            padding: 10px;
            border-left: 4px solid #e74c3c;
            margin-top: 10px;
        }
        details {
            margin-top: 10px;
        }
        summary {
            cursor: pointer;
            font-weight: bold;
        }
        pre {
            background-color: #f1f1f1;
            padding: 15px;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>

    <div class="section">
        <h2>1. Adaptive Traffic Signal Control</h2>
        <p><strong>Problem:</strong> Inefficient traffic signals causing congestion due to fixed timing, especially during high or low traffic volumes.</p>
        <p><strong>Real-Time Example:</strong> In a city like Paris, during rush hours, one direction of traffic may face excessive delays, while in the opposite direction, traffic is sparse.</p>
        <div class="solution">
            <p><strong>Solution using Algorithm:</strong></p>
            <p>- <strong>Heap Sort & Binary Search Trees (BST):</strong></p>
            <ul>
                <li><strong>Heap Sort</strong> can be used to prioritize traffic based on real-time flow. When traffic flow data from sensors are received, vehicles in the congested areas can be prioritized.</li>
                <li><strong>Binary Search Trees (BST)</strong> help in maintaining and quickly retrieving the traffic data in sorted order for processing traffic signals.</li>
            </ul>
        </div>
        <div class="example">
            <p><strong>How It Helps:</strong></p>
            <ul>
                <li><strong>Efficient Traffic Sorting:</strong> Heap sort prioritizes intersections or lanes with higher congestion, ensuring traffic flow is better managed.</li>
                <li><strong>Quick Access to Data:</strong> Binary search trees allow for efficient management of data points (e.g., vehicle counts, signal times), reducing the time taken to adjust signal timings.</li>
            </ul>
        </div>
        <div class="algorithm">
            <p><strong>Example:</strong> In cities like Seoul, smart traffic management systems adjust green light durations in real-time by sorting traffic flow data efficiently.</p>
        </div>

        <details>
            <summary>Heap Sort and Binary Search Tree Code</summary>
            <pre>
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>

using namespace std;

// Function for heap sort
void heapify(vector<int>& arr, int n, int i) {
    int largest = i;
    int left = 2*i + 1;
    int right = 2*i + 2;
    
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

// Binary Search Tree (BST) Node
struct Node {
    int key;
    Node* left, *right;
    Node(int k) : key(k), left(nullptr), right(nullptr) {}
};

// Function to insert a new node in the BST
Node* insert(Node* root, int key) {
    if (root == nullptr) return new Node(key);
    if (key < root->key) root->left = insert(root->left, key);
    else root->right = insert(root->right, key);
    return root;
}

// Function to print the BST In-order traversal
void inorder(Node* root) {
    if (root == nullptr) return;
    inorder(root->left);
    cout << root->key << " ";
    inorder(root->right);
}

int main() {
    vector<int> trafficData = {7, 2, 5, 9, 4, 1, 8};
    
    // Heap Sort
    int n = trafficData.size();
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(trafficData, n, i);
    }
    for (int i = n - 1; i >= 0; i--) {
        swap(trafficData[0], trafficData[i]);
        heapify(trafficData, i, 0);
    }
    
    cout << "Sorted traffic data (Heap Sort): ";
    for (int i = 0; i < n; i++) {
        cout << trafficData[i] << " ";
    }
    cout << endl;
    
    // BST Example
    Node* root = nullptr;
    root = insert(root, 5);
    root = insert(root, 2);
    root = insert(root, 8);
    root = insert(root, 1);
    root = insert(root, 3);
    
    cout << "In-order traversal of the BST: ";
    inorder(root);
    cout << endl;
    
    return 0;
}
            </pre>
        </details>
    </div>

    <div class="section">
        <h2>2. Green Corridors for Pollution Reduction</h2>
        <p><strong>Problem:</strong> Increased emissions and pollution from vehicles stopping at multiple traffic lights.</p>
        <p><strong>Real-Time Example:</strong> In cities like London, vehicles may get stuck at multiple red lights, resulting in significant air pollution due to idling.</p>
        <div class="solution">
            <p><strong>Solution using Algorithm:</strong></p>
            <p>- <strong>Prim’s Algorithm (Minimum Spanning Tree - MST):</strong></p>
            <ul>
                <li><strong>Prim’s algorithm</strong> is used to find the minimum spanning tree that connects multiple intersections with minimal traffic signal stops. The objective is to find a way to create a "green corridor" where traffic can flow uninterrupted with minimal red lights.</li>
            </ul>
        </div>
        <div class="example">
            <p><strong>How It Helps:</strong></p>
            <ul>
                <li><strong>Minimizing Stops:</strong> By applying Prim’s MST, we can synchronize signals along a path (green corridor), allowing vehicles to pass through without stopping, thereby reducing emissions.</li>
                <li><strong>Pollution Reduction:</strong> Fewer stops mean lower emissions, which directly reduces air pollution.</li>
            </ul>
        </div>
        <div class="algorithm">
            <p><strong>Example:</strong> In cities like San Francisco, "green wave" technologies use algorithms similar to Prim’s to ensure smoother traffic flow and lower emission levels.</p>
        </div>

        <details>
            <summary>Prim’s Algorithm Code</summary>
            <pre>
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

#define V 5 // Number of vertices

int minKey(int key[], bool mstSet[]) {
    int min = INT_MAX, min_index;
    for (int v = 0; v < V; v++) {
        if (!mstSet[v] && key[v] < min) {
            min = key[v];
            min_index = v;
        }
    }
    return min_index;
}

void printMST(int parent[], int graph[V][V]) {
    cout << "Edge \tWeight\n";
    for (int i = 1; i < V; i++) {
        cout << parent[i] << " - " << i << "\t" << graph[i][parent[i]] << endl;
    }
}

void primMST(int graph[V][V]) {
    int parent[V]; // Array to store the constructed MST
    int key[V]; // Key values to pick minimum weight edge
    bool mstSet[V]; // To represent the vertices included in MST

    for (int i = 0; i < V; i++) {
        key[i] = INT_MAX;
        mstSet[i] = false;
    }

    key[0] = 0;
    parent[0] = -1;

    for (int count = 0; count < V - 1; count++) {
        int u = minKey(key, mstSet);
        mstSet[u] = true;

        for (int v = 0; v < V; v++) {
            if (graph[u][v] && !mstSet[v] && graph[u][v] < key[v]) {
                parent[v] = u;
                key[v] = graph[u][v];
            }
        }
    }

    printMST(parent, graph);
}

int main() {
    int graph[V][V] = { {0, 2, 0, 6, 0},
                        {2, 0, 3, 8, 5},
                        {0, 3, 0, 0, 7},
                        {6, 8, 0, 0, 9},
                        {0, 5, 7, 9, 0} };

    primMST(graph);

    return 0;
}
            </pre>
        </details>
    </div>

    <div class="section">
        <h2>3. Shortest Path for Emergency Vehicles</h2>
        <p><strong>Problem:</strong> Difficulty in finding the fastest route for emergency vehicles due to unpredictable traffic conditions.</p>
        <p><strong>Real-Time Example:</strong> In a city like New York, emergency vehicles often face traffic congestion that delays their response time.</p>
        <div class="solution">
            <p><strong>Solution using Algorithm:</strong></p>
            <p>- <strong>Dijkstra's Algorithm:</strong></p>
            <ul>
                <li><strong>Dijkstra’s Algorithm</strong> can be used to calculate the shortest path from the current location of an emergency vehicle to its destination, considering real-time road conditions (traffic, road closures, etc.).</li>
            </ul>
        </div>
        <div class="example">
            <p><strong>How It Helps:</strong></p>
            <ul>
                <li><strong>Optimized Routes:</strong> Dijkstra’s algorithm ensures that emergency vehicles take the quickest available route, reducing response time.</li>
                <li><strong>Real-Time Adjustments:</strong> The algorithm can be adjusted to factor in real-time traffic data, ensuring that the shortest path is recalculated as needed.</li>
            </ul>
        </div>

        <details>
            <summary>Dijkstra’s Algorithm Code</summary>
            <pre>
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

#define V 9

int minDistance(int dist[], bool sptSet[]) {
    int min = INT_MAX, min_index;
    for (int v = 0; v < V; v++) {
        if (!sptSet[v] && dist[v] <= min) {
            min = dist[v];
            min_index = v;
        }
    }
    return min_index;
}

void dijkstra(int graph[V][V], int src) {
    int dist[V];
    bool sptSet[V];

    for (int i = 0; i < V; i++) {
        dist[i] = INT_MAX;
        sptSet[i] = false;
    }

    dist[src] = 0;

    for (int count = 0; count < V - 1; count++) {
        int u = minDistance(dist, sptSet);
        sptSet[u] = true;

        for (int v = 0; v < V; v++) {
            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) {
                dist[v] = dist[u] + graph[u][v];
            }
        }
    }

    cout << "Vertex \t Distance from Source\n";
    for (int i = 0; i < V; i++) {
        cout << i << " \t " << dist[i] << endl;
    }
}

int main() {
    int graph[V][V] = { {0, 4, 0, 0, 0, 0, 0, 8, 0},
                        {4, 0, 8, 0, 0, 0, 0, 0, 0},
                        {0, 8, 0, 7, 0, 4, 0, 0, 0},
                        {0, 0, 7, 0, 9, 0, 14, 0, 0},
                        {0, 0, 0, 9, 0, 10, 0, 0, 0},
                        {0, 0, 4, 0, 10, 0, 2, 0, 0},
                        {0, 0, 0, 14, 0, 2, 0, 1, 6},
                        {8, 0, 0, 0, 0, 0, 1, 0, 7},
                        {0, 0, 0, 0, 0, 0, 6, 7, 0} };

    dijkstra(graph, 0);

    return 0;
}
            </pre>
        </details>
    </div>

    <div class="section">
        <h2>4. Optimized Traffic Routing for Public Transport</h2>
        <p><strong>Problem:</strong> Inefficiency in public transport routes causing delays and overcrowding.</p>
        <p><strong>Real-Time Example:</strong> In cities like Tokyo, buses and trains may experience delays due to suboptimal route planning.</p>
        <div class="solution">
            <p><strong>Solution using Algorithm:</strong></p>
            <p>- <strong>Kruskal’s Algorithm (Minimum Spanning Tree):</strong></p>
            <ul>
                <li><strong>Kruskal’s Algorithm</strong> can be used to create an optimized network of routes for public transportation systems, ensuring that the minimal number of connections are used, leading to faster travel times.</li>
            </ul>
        </div>
        <div class="example">
            <p><strong>How It Helps:</strong></p>
            <ul>
                <li><strong>Efficient Routing:</strong> Kruskal’s algorithm minimizes the number of routes while maintaining an optimal connection between stops, reducing travel time.</li>
                <li><strong>Reduced Overcrowding:</strong> Optimizing routes based on the algorithm ensures that buses and trains are distributed more evenly across the network.</li>
            </ul>
        </div>

        <details>
            <summary>Kruskal’s Algorithm Code</summary>
            <pre>
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Edge {
public:
    int src, dest, weight;
    Edge(int s, int d, int w) : src(s), dest(d), weight(w) {}
};

bool compare(Edge e1, Edge e2) {
    return e1.weight < e2.weight;
}

class DisjointSet {
public:
    vector<int> parent, rank;
    
    DisjointSet(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++) parent[i] = i;
    }
    
    int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }
    
    void unionSets(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            if (rank[rootX] > rank[rootY]) 
                parent[rootY] = rootX;
            else if (rank[rootX] < rank[rootY]) 
                parent[rootX] = rootY;
            else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }
};

void kruskal(vector<Edge>& edges, int V) {
    sort(edges.begin(), edges.end(), compare);
    
    DisjointSet ds(V);
    vector<Edge> mst;
    
    for (auto& e : edges) {
        int u = e.src;
        int v = e.dest;
        
        if (ds.find(u) != ds.find(v)) {
            mst.push_back(e);
            ds.unionSets(u, v);
        }
    }
    
    cout << "Edges in MST:" << endl;
    for (auto& e : mst) {
        cout << e.src << " - " << e.dest << " : " << e.weight << endl;
    }
}

int main() {
    vector<Edge> edges;
    edges.push_back(Edge(0, 1, 10));
    edges.push_back(Edge(0, 2, 6));
    edges.push_back(Edge(0, 3, 5));
    edges.push_back(Edge(1, 3, 15));
    edges.push_back(Edge(2, 3, 4));

    int V = 4; // Number of vertices
    kruskal(edges, V);
    return 0;
}
            </pre>
        </details>
    </div>
                 </div>
             </div>





    <h1 onclick="toggleDetails('disasterDetails')">Impact of Natural Disasters</h1>
    <div id="disasterDetails" style="display: none;">
        <div class="section">
            <h2>Target 11.5</h2>
            <p>Significantly reduce the number of deaths and people affected by disasters, with a focus on protecting the poor and vulnerable.</p>
        </div>
        <div class="section">
            <h3>Indicators</h3>
            <ul>
                <li><strong>Indicator 11.5.1:</strong> Number of deaths, missing persons, and directly affected persons attributed to disasters per 100,000 population.</li>
                <li><strong>Indicator 11.5.2:</strong> Direct economic loss attributed to disasters in relation to global domestic product (GDP).</li>
            </ul>
        </div>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Impact of Natural Disasters on Cities - Case Study</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f9;
        }
        h1, h2 {
            color: #333;
        }
        table {
            width: 100%;
            margin: 20px 0;
            border-collapse: collapse;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #4CAF50;
            color: white;
        }
        .section {
            margin-bottom: 40px;
        }
        .collapsible {
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            padding: 10px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 15px;
        }
        .collapsible:hover {
            background-color: #45a049;
        }
        .content {
            padding: 0 18px;
            display: none;
            overflow: hidden;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            margin-top: 5px;
        }
        pre {
            background: #272822;
            color: #f8f8f2;
            padding: 10px;
            overflow-x: auto;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <p>This case study examines various algorithms and data structures used to address challenges arising from natural disasters in cities. By applying concepts like AVL trees, sorting techniques, edges, nodes, and skip lists, we can create more effective strategies for disaster preparedness, response, and recovery.</p>

    <div class="section">
        <h2>Algorithms for Disaster Management</h2>
        <p>Various algorithms are used to solve different aspects of disaster management, such as evacuation planning, resource distribution, and damage assessment. Below are the algorithms and data structures used in the case study:</p>

        <h3>AVL Tree</h3>
        <p><strong>Purpose:</strong> Maintaining a balanced dataset for disaster-related information like shelter availability or hospital capacity.</p>
        <button class="collapsible">Show AVL Tree C++ Code</button>
        <div class="content">
            <pre>
#include <iostream>
using namespace std;

struct Node {
    int key;
    Node* left;
    Node* right;
    int height;
};

int height(Node* N) {
    return N == nullptr ? 0 : N->height;
}

Node* newNode(int key) {
    Node* node = new Node();
    node->key = key;
    node->left = node->right = nullptr;
    node->height = 1;
    return node;
}

Node* rotateRight(Node* y) {
    Node* x = y->left;
    Node* T2 = x->right;
    x->right = y;
    y->left = T2;
    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;
    return x;
}

Node* rotateLeft(Node* x) {
    Node* y = x->right;
    Node* T2 = y->left;
    y->left = x;
    x->right = T2;
    x->height = max(height(x->left), height(x->right)) + 1;
    y->height = max(height(y->left), height(y->right)) + 1;
    return y;
}

int getBalance(Node* N) {
    return N == nullptr ? 0 : height(N->left) - height(N->right);
}

Node* insert(Node* node, int key) {
    if (node == nullptr) return newNode(key);
    if (key < node->key) node->left = insert(node->left, key);
    else if (key > node->key) node->right = insert(node->right, key);
    else return node;
    node->height = 1 + max(height(node->left), height(node->right));
    int balance = getBalance(node);
    if (balance > 1 && key < node->left->key) return rotateRight(node);
    if (balance < -1 && key > node->right->key) return rotateLeft(node);
    if (balance > 1 && key > node->left->key) {
        node->left = rotateLeft(node->left);
        return rotateRight(node);
    }
    if (balance < -1 && key < node->right->key) {
        node->right = rotateRight(node->right);
        return rotateLeft(node);
    }
    return node;
}

void preOrder(Node* root) {
    if (root != nullptr) {
        cout << root->key << " ";
        preOrder(root->left);
        preOrder(root->right);
    }
}

int main() {
    Node* root = nullptr;
    root = insert(root, 10);
    root = insert(root, 20);
    root = insert(root, 30);
    root = insert(root, 40);
    root = insert(root, 50);
    root = insert(root, 25);
    cout << "Preorder traversal of the AVL tree is:\n";
    preOrder(root);
    return 0;
}
            </pre>
        </div>

        <h3>Sorting Techniques</h3>
        <p><strong>Purpose:</strong> Efficiently sorting disaster-related data for prioritization, such as ranking affected areas by severity or organizing resources for distribution.</p>
        <button class="collapsible">Show Sorting Techniques C++ Code</button>
        <div class="content">
            <pre>
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void merge(vector<int>& arr, int l, int m, int r) {
    int n1 = m - l + 1;
    int n2 = r - m;
    vector<int> L(n1), R(n2);
    for (int i = 0; i < n1; i++) L[i] = arr[l + i];
    for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];
    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) arr[k++] = L[i++];
        else arr[k++] = R[j++];
    }
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

void mergeSort(vector<int>& arr, int l, int r) {
    if (l >= r) return;
    int m = l + (r - l) / 2;
    mergeSort(arr, l, m);
    mergeSort(arr, m + 1, r);
    merge(arr, l, m, r);
}

int main() {
    vector<int> data = {38, 27, 43, 3, 9, 82, 10};
    cout << "Original array:\n";
    for (int num : data) cout << num << " ";
    cout << endl;
    mergeSort(data, 0, data.size() - 1);
    cout << "Sorted array:\n";
    for (int num : data) cout << num << " ";
    cout << endl;
    return 0;
}
            </pre>
        </div>

        <h3>Graph Algorithms (Dijkstra's)</h3>
        <p><strong>Purpose:</strong> Finding the shortest evacuation paths during disasters to minimize response time.</p>
        <button class="collapsible">Show Dijkstra's Algorithm C++ Code</button>
        <div class="content">
            <pre>
#include <iostream>
#include <vector>
#include <queue>
#include <utility>
#include <climits>
using namespace std;

typedef pair<int, int> pii;

void dijkstra(int src, const vector<vector<pii>>& graph, vector<int>& dist) {
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    pq.push({0, src});
    dist[src] = 0;

    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();

        for (auto& neighbor : graph[u]) {
            int v = neighbor.first;
            int weight = neighbor.second;

            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
}

int main() {
    int V = 5;
    vector<vector<pii>> graph(V);
    graph[0].push_back({1, 2});
    graph[0].push_back({3, 1});
    graph[1].push_back({3, 3});
    graph[1].push_back({4, 5});
    graph[2].push_back({1, 1});
    graph[3].push_back({2, 4});
    graph[3].push_back({4, 2});

    vector<int> dist(V, INT_MAX);
    dijkstra(0, graph, dist);

    cout << "Shortest distances from source 0:\n";
    for (int i = 0; i < V; ++i) {
        cout << "Vertex " << i << ": " << dist[i] << endl;
    }

    return 0;
}
            </pre>
        </div>

    </div>

    <script>
        const collapsibles = document.querySelectorAll(".collapsible");
        collapsibles.forEach(button => {
            button.addEventListener("click", function () {
                this.classList.toggle("active");
                const content = this.nextElementSibling;
                if (content.style.display === "block") {
                    content.style.display = "none";
                } else {
                    content.style.display = "block";
                }
            });
        });
    </script>

        </div>
    </div>

    <h1 onclick="toggleDetails('tourismDetails')">Efficient Management of Tourism</h1>
    <div id="tourismDetails" style="display: none;">
        <div class="section">
            <h2>Introduction</h2>
            <p>Tourism is a critical driver of economic growth, cultural exchange, and urban development in modern cities. By focusing on innovation, sustainability, and inclusivity, cities can design tourism systems that not only attract visitors but also enrich the lives of residents and support long-term economic growth.</p>
        </div>
        <div class="content">
        <h2>SDG 11.4: Protecting and Safeguarding Cultural and Natural Heritage</h2>
        <p><strong>Efficient tourism management aligns with SDG 11.4 by ensuring:</strong></p>
        <ul>
            <li>Sustainable use of natural and cultural resources.</li>
            <li>Reduction of overcrowding and degradation of cultural sites.</li>
            <li>Utilization of technology to monitor and manage visitor impacts on destinations.</li>
        </ul>

        <h3>Relevant Indicators from UNSDG 11:</h3>
        <ul>
            <li><strong>11.4.1</strong> - Total expenditure for conservation and protection of cultural and natural heritage as a percentage of total tourism expenditure.</li>
            <li><strong>11.4.2</strong> - Proportion of cultural and natural heritage sites that are managed using sustainable practices.</li>
            <li><strong>11.4.3</strong> - The number of sites included in the World Heritage list, and the status of the conservation efforts on those sites.</li>
        </ul>
    </div>
        <div class="section">
            <h3>Steps for Managing Tourism</h3>
            <h4>Identifying Popular Tourism Spots</h4>
            <p><strong>Problem:</strong> Identifying the most visited tourist spots in a city is crucial for effective resource allocation and planning.</p>
            <p><strong>Solution:</strong> Sorting these spots based on the number of visits helps optimize infrastructure, manage crowds, and prioritize promotional efforts.</p>
        </div>
        <div class="section">
         
    <div class="content">
        <h2>Steps for Managing Tourism</h2>

        <div class="algorithm-section">
            <h3>1. Ranking Popular Tourism Spots</h3>
            <p><strong>Problem:</strong> Cities need to prioritize tourist spots based on popularity for efficient resource allocation.</p>
            <p><strong>Solution:</strong> Use <strong>Merge Sort</strong> to rank locations by visitor count.</p>

            <h4>Algorithm: Merge Sort</h4>
            <p><strong>Purpose:</strong> Sort tourism spots by their annual or monthly visit counts.</p>
            <p><strong>Implementation:</strong></p>
            <ul>
                <li><strong>Input:</strong> List of tourist spots with visit counts.</li>
                <li><strong>Output:</strong> Sorted list of spots from highest to lowest visits.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>Spots: Central Plaza (120,000), Lakeview Park (80,000), Hilltop Observatory (100,000), Historic Market (95,000).
Result (sorted): Central Plaza → Hilltop Observatory → Historic Market → Lakeview Park.</code></pre>
        </div>

        <div class="algorithm-section">
            <h3>2. Finding Optimal Paths Between Tourist Spots</h3>
            <p><strong>Problem:</strong> Tourists need to travel efficiently between attractions.</p>
            <p><strong>Solution:</strong> Use <strong>Floyd-Warshall</strong> for finding the shortest paths between all pairs of spots.</p>

            <h4>Algorithm: Floyd-Warshall</h4>
            <p><strong>Purpose:</strong> Compute shortest paths between all tourist spots in a city.</p>
            <p><strong>Implementation:</strong></p>
            <ul>
                <li><strong>Input:</strong> A graph representing tourist spots as nodes and roads with travel times as edges.</li>
                <li><strong>Output:</strong> A matrix with shortest travel times between all pairs of spots.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>Areas: Central Plaza, Lakeview Park, Hilltop Observatory, Historic Market.
Result:  
Shortest Path Matrix:
Central Plaza → Lakeview Park: 15 mins  
Lakeview Park → Hilltop Observatory: 20 mins  
Central Plaza → Hilltop Observatory: 30 mins  
...</code></pre>
        </div>

        <div class="algorithm-section">
            <h3>3. Predicting Visitor Trends</h3>
            <p><strong>Problem:</strong> Accurate prediction of tourist footfall helps in preparing for peak seasons.</p>
            <p><strong>Solution:</strong> Use <strong>Dijkstra's Algorithm</strong> to find the most optimal routes that visitors take, which can be used to predict where congestion or high footfall may occur.</p>

            <h4>Algorithm: Dijkstra's Algorithm</h4>
            <p><strong>Purpose:</strong> Find the shortest path in terms of travel time or distance from one location to another, helping to predict the flow of visitors between popular spots.</p>
            <p><strong>Concept:</strong> Dijkstra’s algorithm calculates the shortest path from a starting node (tourist spot) to all other nodes (other spots), helping in understanding which routes will see the most visitors. By examining the number of visitors traveling along each route, the algorithm can predict footfall at different locations.</p>
            <p><strong>Implementation:</strong></p>
            <ul>
                <li><strong>Input:</strong> A graph of tourist spots with weighted edges representing the time or distance between spots.</li>
                <li><strong>Output:</strong> Shortest paths from one spot to all others.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>Areas: Central Plaza → Hilltop Observatory → Lakeview Park.
Result: Dijkstra’s algorithm finds the fastest paths, which can predict that Central Plaza will see heavy traffic because it's connected to several key locations.</code></pre>
        </div>

        <div class="algorithm-section">
            <h3>4. Reducing Congestion Using Dynamic Routing</h3>
            <p><strong>Problem:</strong> Popular spots often face traffic congestion, frustrating tourists and locals.</p>
            <p><strong>Solution:</strong> Implement <strong>Bellman-Ford Algorithm</strong> to reroute tourists dynamically.</p>

            <h4>Algorithm: Bellman-Ford</h4>
            <p><strong>Purpose:</strong> Identify shortest paths dynamically, even with real-time traffic changes.</p>
            <p><strong>Implementation:</strong></p>
            <ul>
                <li><strong>Input:</strong> Real-time traffic data and travel time updates for roads.</li>
                <li><strong>Output:</strong> Adjusted routes to reduce congestion.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>Congestion detected on the main road to Central Plaza.
Result: Tourists rerouted via secondary roads to reach the spot.</code></pre>
        </div>

        <div class="algorithm-section">
            <h3>5. Dynamic Pricing for Seasonal Demand</h3>
            <p><strong>Problem:</strong> Tourism revenue can be maximized with dynamic pricing strategies.</p>
            <p><strong>Solution:</strong> Use <strong>Breadth-First Search (BFS)</strong> to identify and price tourist spots based on demand and distance from popular tourist areas.</p>

            <h4>Algorithm: Breadth-First Search (BFS)</h4>
            <p><strong>Purpose:</strong> Explore all possible tourist spots by visiting neighboring nodes first, helping to identify which spots are the most connected and, therefore, most likely to experience higher footfall. The algorithm can then be used for dynamic pricing by identifying the spots with the highest demand and adjusting prices accordingly.</p>
            <p><strong>Concept:</strong> BFS explores all tourist spots level by level, starting from the most popular spots and expanding outward. This can be used to identify tourist spots that may see increasing demand as people visit nearby spots.</p>
            <p><strong>Implementation:</strong></p>
            <ul>
                <li><strong>Input:</strong> A graph of tourist spots and their connections (i.e., which spots are connected to each other).</li>
                <li><strong>Output:</strong> Identifying tourist spots that are likely to be visited based on proximity to other spots.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <pre><code>Area: Lakeview Park (central location) → Nearby attractions (Historic Market, Hilltop Observatory).
Result: Dynamic pricing adjusts as more tourists visit neighboring spots.</code></pre>
        </div>

    </div>

    <div class="content">
        <h2>Conclusion</h2>
        <p>By employing algorithms such as <strong>Merge Sort</strong> for ranking, <strong>Floyd-Warshall</strong> for route optimization, <strong>Dijkstra's Algorithm</strong> for predicting visitor trends, and <strong>Breadth-First Search (BFS)</strong> for dynamic pricing, cities can design smarter tourism systems. These data-driven approaches enhance efficiency, support sustainability, and improve the visitor experience.</p>
    </div>

</body>
</html>

</body>
</html>
