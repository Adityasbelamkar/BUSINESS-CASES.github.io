<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Traffic Management and Disaster Impact</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #eef2f3;
            color: #333;
        }
        h1 {
            color: #ffffff;
            background: #2c3e50;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            margin-top: 50px;
        }
        h2, h3 {
            color: #2c3e50;
        }
        #instructions {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2em;
            background: #d6eaf8;
            padding: 15px;
            border: 1px solid #aed6f1;
            border-radius: 10px;
        }
        #details {
            display: none;
            margin-top: 20px;
        }
        .section {
            background: #ffffff;
            border: 1px solid #d5d8dc;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        ul {
            list-style-type: square;
            margin-left: 20px;
        }
        footer {
            text-align: center;
            margin-top: 20px;
            font-size: 0.9em;
            color: #555;
        }
        pre {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #dcdcdc;
            overflow-x: auto;
        }
    </style>
    <script>
        function toggleDetails(id) {
            const details = document.getElementById(id);
            details.style.display = details.style.display === 'none' ? 'block' : 'none';
        }
    </script>
</head>
<body>
    <div id="instructions">
        <p>Click on the business cases to know about them..</p>
    </div>

    <h1 onclick="toggleDetails('trafficDetails')">Smart Traffic Management System</h1>
    <div id="trafficDetails" style="display: none;">
        <div class="section">
            <h2>Smart Traffic Management Systems</h2>
            <p>Target 11.7: Provide Access to Safe and Inclusive Green and Public Spaces</p>
            <p><strong>Target:</strong> By 2030, provide universal access to safe, inclusive, and accessible, green and public spaces, particularly for women and children, older persons, and persons with disabilities.</p>
        </div>
        <div class="section">
            <h3>Indicators</h3>
            <ul>
                <li><strong>Indicator 11.7.1:</strong> Average share of the built-up area of cities that is open space for public use for all, by sex, age, and persons with disabilities.</li>
                <li><strong>Indicator 11.7.2:</strong> Proportion of persons victimized by physical or sexual harassment, by sex, age, disability status, and place of occurrence, in the previous 12 months.</li>
            </ul>
        </div>
        <div class="section">
            <h3>Examples</h3>
            <p>Smart Traffic Management can include:</p>
            <ul>
                <li>Adaptive traffic signal systems that respond to real-time congestion.</li>
                <li>Integration of green corridors to reduce pollution and enhance public spaces.</li>
                <li>Advanced route planning for emergency and public transport vehicles.</li>
            </ul>
        </div>
        <div class="section">
            <h3>Advantages</h3>
            <ul>
                <li><strong>Cost Efficiency:</strong> Reduces fuel consumption and operational costs by minimizing congestion.</li>
                <li><strong>Improved Traffic Flow:</strong> Decreases bottlenecks and enhances movement across the network.</li>
                <li><strong>Scalability:</strong> Effective in both small and large cities, adapting as urban areas grow.</li>
                <li><strong>Safety:</strong> Enhances road safety and reduces accidents through optimized systems.</li>
            </ul>
        </div>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Traffic Management Case Study</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 40px;
            background-color: #f4f4f9;
        }
        h1, h2 {
            color: #333;
        }
        .section {
            margin-bottom: 20px;
        }
        .solution {
            background-color: #e9f7ef;
            padding: 15px;
            border-left: 4px solid #2ecc71;
        }
        .example {
            background-color: #f9f9f9;
            border-left: 4px solid #3498db;
            padding: 10px;
            margin-top: 10px;
        }
        .algorithm {
            background-color: #f8d7da;
            padding: 10px;
            border-left: 4px solid #e74c3c;
            margin-top: 10px;
        }
    </style>
</head>
<body>


    <div class="section">
        <h2>1. Adaptive Traffic Signal Control</h2>
        <p><strong>Problem:</strong> Inefficient traffic signals causing congestion due to fixed timing, especially during high or low traffic volumes.</p>
        <p><strong>Real-Time Example:</strong> In a city like Paris, during rush hours, one direction of traffic may face excessive delays, while in the opposite direction, traffic is sparse.</p>
        <div class="solution">
            <p><strong>Solution using Algorithm:</strong></p>
            <p>- <strong>Heap Sort & Binary Search Trees (BST):</strong></p>
            <ul>
                <li><strong>Heap Sort</strong> can be used to prioritize traffic based on real-time flow. When traffic flow data from sensors are received, vehicles in the congested areas can be prioritized.</li>
                <li><strong>Binary Search Trees (BST)</strong> help in maintaining and quickly retrieving the traffic data in sorted order for processing traffic signals.</li>
            </ul>
        </div>
        <div class="example">
            <p><strong>How It Helps:</strong></p>
            <ul>
                <li><strong>Efficient Traffic Sorting:</strong> Heap sort prioritizes intersections or lanes with higher congestion, ensuring traffic flow is better managed.</li>
                <li><strong>Quick Access to Data:</strong> Binary search trees allow for efficient management of data points (e.g., vehicle counts, signal times), reducing the time taken to adjust signal timings.</li>
            </ul>
        </div>
        <div class="algorithm">
            <p><strong>Example:</strong> In cities like Seoul, smart traffic management systems adjust green light durations in real-time by sorting traffic flow data efficiently.</p>
        </div>
    </div>

    <div class="section">
        <h2>2. Green Corridors for Pollution Reduction</h2>
        <p><strong>Problem:</strong> Increased emissions and pollution from vehicles stopping at multiple traffic lights.</p>
        <p><strong>Real-Time Example:</strong> In cities like London, vehicles may get stuck at multiple red lights, resulting in significant air pollution due to idling.</p>
        <div class="solution">
            <p><strong>Solution using Algorithm:</strong></p>
            <p>- <strong>Prim’s Algorithm (Minimum Spanning Tree - MST):</strong></p>
            <ul>
                <li><strong>Prim’s algorithm</strong> is used to find the minimum spanning tree that connects multiple intersections with minimal traffic signal stops. The objective is to find a way to create a "green corridor" where traffic can flow uninterrupted with minimal red lights.</li>
            </ul>
        </div>
        <div class="example">
            <p><strong>How It Helps:</strong></p>
            <ul>
                <li><strong>Minimizing Stops:</strong> By applying Prim’s MST, we can synchronize signals along a path (green corridor), allowing vehicles to pass through without stopping, thereby reducing emissions.</li>
                <li><strong>Pollution Reduction:</strong> Fewer stops mean lower emissions, which directly reduces air pollution.</li>
            </ul>
        </div>
        <div class="algorithm">
            <p><strong>Example:</strong> In cities like San Francisco, "green wave" technologies use algorithms similar to Prim’s to ensure smoother traffic flow and lower emission levels.</p>
        </div>
    </div>

    <div class="section">
        <h2>3. Route Planning for Emergency Vehicles</h2>
        <p><strong>Problem:</strong> Delays in emergency vehicles like ambulances due to traffic congestion.</p>
        <p><strong>Real-Time Example:</strong> In busy urban centers like Los Angeles, an ambulance may get stuck in traffic, causing delays in reaching emergencies.</p>
        <div class="solution">
            <p><strong>Solution using Algorithm:</strong></p>
            <p>- <strong>Dijkstra’s Algorithm (Shortest Path):</strong></p>
            <ul>
                <li><strong>Dijkstra’s algorithm</strong> calculates the shortest path for emergency vehicles from their current location to the destination by dynamically adjusting to real-time road closures and traffic data.</li>
            </ul>
        </div>
        <div class="example">
            <p><strong>How It Helps:</strong></p>
            <ul>
                <li><strong>Quickest Route:</strong> This ensures that emergency vehicles take the shortest, fastest route based on real-time traffic conditions.</li>
                <li><strong>Dynamic Adaptation:</strong> The algorithm adapts based on road closures or changing traffic patterns, allowing the vehicle to reroute instantly.</li>
            </ul>
        </div>
        <div class="algorithm">
            <p><strong>Example:</strong> Emergency vehicles in cities like New York utilize similar algorithms to ensure faster response times.</p>
        </div>
    </div>

    <div class="section">
        <h2>4. Public Transport Optimization</h2>
        <p><strong>Problem:</strong> Inefficient public transport schedules lead to overcrowded buses/trains or underutilized resources.</p>
        <p><strong>Real-Time Example:</strong> In cities like São Paulo, buses might arrive either too early or too late, causing either overcrowding or underuse.</p>
        <div class="solution">
            <p><strong>Solution using Algorithm:</strong></p>
            <p>- <strong>Quick Sort & AVL Trees (Balanced Binary Search Trees):</strong></p>
            <ul>
                <li><strong>Quick Sort</strong> can be applied to sort buses based on their routes or scheduled arrival times, ensuring that transport resources are used efficiently.</li>
                <li><strong>AVL Trees</strong>, a type of self-balancing binary search tree, can be used to store and retrieve sorted data about bus schedules, ensuring quick adjustments based on real-time passenger demand.</li>
            </ul>
        </div>
        <div class="example">
            <p><strong>How It Helps:</strong></p>
            <ul>
                <li><strong>Efficient Resource Allocation:</strong> Quick Sort ensures buses are assigned to the most needed routes, while AVL Trees optimize the management of dynamic scheduling data.</li>
                <li><strong>Optimal Utilization:</strong> Adjustments to bus arrival times can be made quickly based on real-time data, ensuring minimal overcrowding and delays.</li>
            </ul>
        </div>
        <div class="algorithm">
            <p><strong>Example:</strong> Cities like Hong Kong and Singapore use AVL Trees to dynamically adjust bus schedules based on demand and road conditions.</p>
        </div>
    </div>

    <div class="section">
        <h2>5. Traffic Flow Prediction and Management</h2>
        <p><strong>Problem:</strong> Sudden traffic jams due to accidents, road closures, or rush hour traffic.</p>
        <p><strong>Real-Time Example:</strong> In cities like Mumbai, sudden traffic jams often occur because of unpredicted accidents or road closures, leading to major delays.</p>
        <div class="solution">
            <p><strong>Solution using Algorithm:</strong></p>
            <p>- <strong>Kruskal’s Algorithm (Minimum Spanning Tree - MST) & Topological Sorting:</strong></p>
            <ul>
                <li><strong>Kruskal’s algorithm</strong> can be used to find the minimum spanning tree of the city's road network, connecting intersections with the least amount of congestion and avoiding heavily trafficked routes. By ensuring that traffic flow on these paths is minimized, congestion is reduced.</li>
                <li><strong>Topological Sorting</strong> can be used to manage and prioritize road closures or diversions to optimize traffic flow during peak congestion times or accidents.</li>
            </ul>
        </div>
        <div class="example">
            <p><strong>How It Helps:</strong></p>
            <ul>
                <li><strong>Optimized Traffic Routing:</strong> Kruskal’s algorithm helps in identifying optimal routes for both regular and emergency traffic.</li>
                <li><strong>Reduced Congestion:</strong> By connecting less congested areas, Kruskal’s can help alleviate traffic in critical spots, particularly after road closures or accidents.</li>
            </ul>
        </div>
        <div class="algorithm">
            <p><strong>Example:</strong> Traffic management systems in cities like London and Paris use graph-based algorithms (such as Kruskal's and Topological Sorting) to manage diversions, optimize detour routes, and avoid congestion.</p>
        </div>
    </div>

    <h2>Conclusion:</h2>
    <p>In this case study, we explored how various <strong>sorting techniques</strong>, <strong>graph algorithms</strong>, and <strong>tree-based algorithms</strong> can contribute to optimizing traffic management systems in urban environments. Here's a summary of the key algorithms applied:</p>
    <ul>
        <li><strong>Heap Sort</strong> and <strong>Binary Search Trees (BST)</strong> for efficient adaptive traffic signal control.</li>
        <li><strong>Prim’s Algorithm (MST)</strong> to create green corridors, reducing pollution by minimizing stops.</li>
        <li><strong>Dijkstra’s Algorithm</strong> for emergency vehicle route planning.</li>
        <li><strong>Quick Sort</strong> and <strong>AVL Trees</strong> for public transport scheduling and optimization.</li>
        <li><strong>Kruskal’s Algorithm (MST)</strong> and <strong>Topological Sorting</strong> for traffic flow prediction and managing congestion.</li>
    </ul>
    <p>These algorithms, applied with real-time data, contribute to reducing congestion, pollution, and delays while improving the overall efficiency of urban traffic systems.</p>
        </div>
    </div>


    <h1 onclick="toggleDetails('disasterDetails')">Impact of Natural Disasters</h1>
    <div id="disasterDetails" style="display: none;">
        <div class="section">
            <h2>Target 11.5</h2>
            <p>Significantly reduce the number of deaths and people affected by disasters, with a focus on protecting the poor and vulnerable.</p>
        </div>
        <div class="section">
            <h3>Indicators</h3>
            <ul>
                <li><strong>Indicator 11.5.1:</strong> Number of deaths, missing persons, and directly affected persons attributed to disasters per 100,000 population.</li>
                <li><strong>Indicator 11.5.2:</strong> Direct economic loss attributed to disasters in relation to global domestic product (GDP).</li>
            </ul>
        </div>
       <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Impact of Natural Disasters on Cities - Case Study</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f9;
        }
        h1, h2 {
            color: #333;
        }
        table {
            width: 100%;
            margin: 20px 0;
            border-collapse: collapse;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #4CAF50;
            color: white;
        }
        .section {
            margin-bottom: 40px;
        }
    </style>
</head>
<body>
    <p>This case study examines various algorithms and data structures used to address challenges arising from natural disasters in cities. By applying concepts like trees, skip lists, edges, nodes, and sorting techniques, we can create more effective strategies for disaster preparedness, response, and recovery.</p>

    <div class="section">
        <h2>Algorithms for Disaster Management</h2>
        <p>Various algorithms are used to solve different aspects of disaster management, such as evacuation planning, resource distribution, and damage assessment. Below are the algorithms and data structures used in the case study:</p>

        <h3>Dijkstra’s Algorithm</h3>
        <p><strong>Purpose:</strong> Finding the shortest and safest routes for evacuation or resource delivery in a disaster-stricken city.</p>
        <p><strong>Application:</strong> Dijkstra’s algorithm is used for optimal routing during evacuations or for distributing resources to critical locations, like hospitals or shelters, by evaluating road conditions in real-time. This algorithm is ideal for routing evacuation or relief efforts, especially in situations where certain routes may be blocked or dangerous due to the disaster.</p>
        <p><strong>Real-Time Data Example:</strong> Use real-time traffic data (e.g., GPS data from vehicles) and disaster-specific conditions (e.g., blocked roads, structural damages) to dynamically update the graph and find the best evacuation routes.</p>
        <p><strong>Example:</strong> During Hurricane Katrina (2005), Dijkstra’s algorithm could be applied to find the optimal evacuation routes for residents based on real-time roadblock data, prioritizing fast and safe escape paths.</p>

        <h3>Kruskal’s Algorithm (Minimum Spanning Tree)</h3>
        <p><strong>Purpose:</strong> Ensuring that resources like water, food, and medical supplies reach all affected areas while minimizing travel time.</p>
        <p><strong>Application:</strong> Use Kruskal’s algorithm to construct a minimum spanning tree (MST) that connects all critical locations in a city (e.g., hospitals, shelters, food depots) using the shortest possible routes. This algorithm is efficient for distributing resources across a network and minimizing the total distance or cost. It is ideal for scenarios where resources need to be delivered across a network in a cost-effective manner.</p>
        <p><strong>Real-Time Data Example:</strong> Use infrastructure data, such as road lengths, travel times, and road condition information, to create the graph where Kruskal’s algorithm can help determine the minimum path for resource distribution.</p>
        <p><strong>Example:</strong> In the aftermath of a disaster like an earthquake, Kruskal’s algorithm can be used to connect emergency services to various shelters, hospitals, and resource depots, ensuring that the relief operation uses the least amount of travel time or resources.</p>

        <h3>Prim’s Algorithm (Minimum Spanning Tree)</h3>
        <p><strong>Purpose:</strong> Optimizing connections between critical infrastructure nodes like power plants, hospitals, and water distribution systems.</p>
        <p><strong>Application:</strong> Prim’s algorithm works similarly to Kruskal's but is more efficient in terms of constructing the minimum spanning tree from a starting node. It’s ideal for optimizing connections between key infrastructure nodes in the city (e.g., power stations, hospitals, water treatment facilities). It’s particularly effective in dense networks where you need to minimize the number of connections while ensuring all nodes are connected.</p>
        <p><strong>Real-Time Data Example:</strong> Data about infrastructure damage, fuel levels, and roadblock conditions can be used to adapt the algorithm and ensure that vital services are connected and operational as soon as possible.</p>
        <p><strong>Example:</strong> After a natural disaster like a flood or earthquake, Prim’s algorithm can help restore the most essential connections first (e.g., linking power plants to hospitals and water stations) to prioritize recovery.</p>

        <h3>Skip List</h3>
        <p><strong>Purpose:</strong> Efficient searching and updating of real-time disaster data, such as the status of roadblocks, shelters, or hospital capacities.</p>
        <p><strong>Application:</strong> A skip list can be used for fast searching and updating of information regarding the current state of different locations in the city. It provides logarithmic time complexity for search, insertion, and deletion operations, making it suitable for dynamic environments like disaster response scenarios where data is constantly changing.</p>
        <p><strong>Real-Time Data Example:</strong> Real-time updates about road closures, shelter availability, or hospital capacity can be stored and managed in a skip list. This allows decision-makers to quickly find the nearest available shelter or the most accessible route to a hospital.</p>
        <p><strong>Example:</strong> During an evacuation due to a wildfire, a skip list can manage real-time updates on road conditions and shelter availability, allowing the authorities to quickly direct evacuees to the nearest available safe location.</p>

        <h3>Breadth-First Search (BFS)</h3>
        <p><strong>Purpose:</strong> Identifying and reaching safe zones (e.g., shelters or evacuation points) in the shortest time possible.</p>
        <p><strong>Application:</strong> BFS can be used to explore the graph layer by layer, starting from a source (e.g., an evacuation point) and finding the shortest paths to various destinations (e.g., safe zones). BFS is ideal for scenarios where the goal is to reach a target in the least number of steps, making it particularly useful for evacuation routing and search operations.</p>
        <p><strong>Real-Time Data Example:</strong> Use real-time maps of the city and dynamic data on road conditions to implement BFS and guide people to the closest safe zones in the fastest possible time.</p>
        <p><strong>Example:</strong> After a flood or earthquake, BFS can be used to guide people from affected buildings to nearby safe zones or shelters, ensuring they reach safety in the shortest time.</p>

        <h3>Depth-First Search (DFS)</h3>
        <p><strong>Purpose:</strong> Exploring all accessible areas for rescue operations or damage assessment.</p>
        <p><strong>Application:</strong> DFS is useful for exploring all possible routes or paths in a city that may be blocked or inaccessible. In situations where resources or search teams need to explore a region (e.g., urban search-and-rescue missions), DFS can help exhaustively check for survivors or assess damage.</p>
        <p><strong>Real-Time Data Example:</strong> Use city mapping and sensor data (e.g., GPS tracking of rescue teams) to guide DFS in exploring areas that need immediate attention.</p>
        <p><strong>Example:</strong> During the 2010 Chilean earthquake, DFS could have been applied in urban search-and-rescue operations to systematically explore buildings and affected regions for survivors.</p>

        <h3>Knuth-Morris-Pratt (KMP) Algorithm</h3>
        <p><strong>Purpose:</strong> Efficiently searching and processing emergency alerts, messages, and disaster-related communications.</p>
        <p><strong>Application:</strong> The KMP algorithm is efficient for searching for specific patterns in a large corpus of text, such as emergency messaging or disaster-related communications. In the context of disaster response, KMP can be used to quickly search for key patterns in emergency alerts (e.g., "flood warning", "evacuation order", "power outage").</p>
        <p><strong>Real-Time Data Example:</strong> Monitor public channels (e.g., emergency SMS, social media, or public broadcasts) and use the KMP algorithm to extract critical messages related to the disaster.</p>
        <p><strong>Example:</strong> In the event of a hurricane, KMP can be used to quickly filter out critical evacuation or safety-related messages from large streams of emergency communication, ensuring that relevant information reaches decision-makers and affected citizens.</p>
    </div>

    <div class="section">
        <h2>Summary of Algorithms and Data Structures</h2>
        <p>Below is a table summarizing the algorithms, their purposes, applications, and the data used for each scenario:</p>

        <table>
            <thead>
                <tr>
                    <th>Algorithm/Data Structure</th>
                    <th>Challenge</th>
                    <th>Use Case</th>
                    <th>Data Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Dijkstra’s Algorithm</td>
                    <td>Shortest route planning for evacuation</td>
                    <td>Finding the shortest path for evacuation and relief distribution</td>
                    <td>Real-time traffic and road conditions, disaster-specific roadblocks</td>
                </tr>
                <tr>
                    <td>Kruskal’s Algorithm</td>
                    <td>Resource distribution (minimum spanning tree)</td>
                    <td>Connecting critical infrastructure nodes for resource delivery</td>
                    <td>Road lengths, travel times, infrastructure damage</td>
                </tr>
                <tr>
                    <td>Prim’s Algorithm</td>
                    <td>Optimizing infrastructure connections</td>
                    <td>Connecting hospitals, power plants, water stations in disaster recovery</td>
                    <td>Infrastructure damage, roadblock data</td>
                </tr>
                <tr>
                    <td>Skip List</td>
                    <td>Efficient searching and updating disaster data</td>
                    <td>Searching and updating real-time disaster data (e.g., shelter status)</td>
                    <td>Real-time updates on road closures, shelter availability</td>
                </tr>
                <tr>
                    <td>BFS</td>
                    <td>Safe zone identification</td>
                    <td>Finding shortest paths to safe zones</td>
                    <td>Real-time evacuation maps, road conditions</td>
                </tr>
                <tr>
                    <td>DFS</td>
                    <td>Exploration for rescue operations</td>
                    <td>Exploring affected areas for survivors or damage assessment</td>
                    <td>GPS tracking of rescue teams, city maps</td>
                </tr>
                <tr>
                    <td>KMP</td>
                    <td>Emergency message pattern matching</td>
                    <td>Searching for critical disaster-related messages</td>
                    <td>Emergency alerts, public communication data</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="section">
        <h2>Best and Most Accurate Algorithm</h2>
        <p><strong>For routing and evacuation:</strong> Dijkstra’s algorithm is ideal because it guarantees the shortest path even in complex, dynamically changing environments.</p>
        <p><strong>For resource optimization:</strong> Both Kruskal’s and Prim’s algorithms are accurate for distributing resources efficiently across a network, but Prim’s algorithm is often preferred for its efficiency in dense graphs.</p>
        <p><strong>For data updates and search:</strong> Skip lists provide fast searching and real-time updates, ensuring efficiency in a rapidly changing disaster environment.</p>
    </div>
        </div>
    </div>

    <h1 onclick="toggleDetails('tourismDetails')">Efficient Management of Tourism</h1>
    <div id="tourismDetails" style="display: none;">
        <div class="section">
            <h2>Introduction</h2>
            <p>Tourism is a critical driver of economic growth, cultural exchange, and urban development in modern cities. By focusing on innovation, sustainability, and inclusivity, cities can design tourism systems that not only attract visitors but also enrich the lives of residents and support long-term economic growth.</p>
        </div>
        <div class="content">
        <h2>SDG 11.4: Protecting and Safeguarding Cultural and Natural Heritage</h2>
        <p><strong>Efficient tourism management aligns with SDG 11.4 by ensuring:</strong></p>
        <ul>
            <li>Sustainable use of natural and cultural resources.</li>
            <li>Reduction of overcrowding and degradation of cultural sites.</li>
            <li>Utilization of technology to monitor and manage visitor impacts on destinations.</li>
        </ul>

        <h3>Relevant Indicators from UNSDG 11:</h3>
        <ul>
            <li><strong>11.4.1</strong> - Total expenditure for conservation and protection of cultural and natural heritage as a percentage of total tourism expenditure.</li>
            <li><strong>11.4.2</strong> - Proportion of cultural and natural heritage sites that are managed using sustainable practices.</li>
            <li><strong>11.4.3</strong> - The number of sites included in the World Heritage list, and the status of the conservation efforts on those sites.</li>
        </ul>
    </div>
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Managing Tourism in Urban Areas</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            background-color: #f0f8ff; /* Light blue background */
            color: #333;
            margin: 0;
            padding: 20px;
        }
        h1, h2 {
            color: #2c3e50;
        }
        h3 {
            color: #16a085;
        }
        .content {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        code {
            background-color: #ecf0f1;
            padding: 5px;
            border-radius: 4px;
            font-family: monospace;
            color: #34495e;
        }
        ul {
            list-style-type: square;
            padding-left: 20px;
        }
        .algorithm-section {
            margin-bottom: 30px;
        }
        .algorithm-code {
            background-color: #eaf2f8;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            display: none;
        }
        h4 {
            color: #2980b9;
            cursor: pointer;
        }
        h4:hover {
            color: #3498db;
        }
    </style>
</head>
<body>

    <div class="content">
        <h2>Steps for Managing Tourism</h2>

        <div class="algorithm-section">
            <h3>1. Ranking Popular Tourism Spots</h3>
            <p><strong>Problem:</strong> Cities need to prioritize tourist spots based on popularity for efficient resource allocation.</p>
            <p><strong>Solution:</strong> Use <strong>Merge Sort</strong> to rank locations by visitor count.</p>

            <h4 onclick="toggleCode('mergeSortCode')">Algorithm: Merge Sort</h4>
            <p><strong>Purpose:</strong> Sort tourism spots by their annual or monthly visit counts.</p>
            <p><strong>Code Example:</strong></p>
            <div id="mergeSortCode" class="algorithm-code">
                <pre><code>
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    let mid = Math.floor(arr.length / 2);
    let left = mergeSort(arr.slice(0, mid));
    let right = mergeSort(arr.slice(mid));
    return merge(left, right);
}

function merge(left, right) {
    let result = [], i = 0, j = 0;
    while (i < left.length && j < right.length) {
        if (left[i].visits > right[j].visits) {
            result.push(left[i]);
            i++;
        } else {
            result.push(right[j]);
            j++;
        }
    }
    return result.concat(left.slice(i)).concat(right.slice(j));
}

const spots = [
    { name: "Central Plaza", visits: 120000 },
    { name: "Lakeview Park", visits: 80000 },
    { name: "Hilltop Observatory", visits: 100000 },
    { name: "Historic Market", visits: 95000 }
];
console.log(mergeSort(spots));
                </code></pre>
            </div>
        </div>

        <div class="algorithm-section">
            <h3>2. Finding Optimal Paths Between Tourist Spots</h3>
            <p><strong>Problem:</strong> Tourists need to travel efficiently between attractions.</p>
            <p><strong>Solution:</strong> Use <strong>Floyd-Warshall</strong> for finding the shortest paths between all pairs of spots.</p>

            <h4 onclick="toggleCode('floydWarshallCode')">Algorithm: Floyd-Warshall</h4>
            <p><strong>Purpose:</strong> Compute shortest paths between all tourist spots in a city.</p>
            <p><strong>Implementation:</strong></p>
            <ul>
                <li><strong>Input:</strong> A graph representing tourist spots as nodes and roads with travel times as edges.</li>
                <li><strong>Output:</strong> A matrix with shortest travel times between all pairs of spots.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <div id="floydWarshallCode" class="algorithm-code">
                <pre><code>Areas: Central Plaza, Lakeview Park, Hilltop Observatory, Historic Market.
Result:  
Shortest Path Matrix:
Central Plaza → Lakeview Park: 15 mins  
Lakeview Park → Hilltop Observatory: 20 mins  
Central Plaza → Hilltop Observatory: 30 mins  
...</code></pre>
            </div>
        </div>

        <div class="algorithm-section">
            <h3>3. Predicting Visitor Trends</h3>
            <p><strong>Problem:</strong> Accurate prediction of tourist footfall helps in preparing for peak seasons.</p>
            <p><strong>Solution:</strong> Use <strong>Dijkstra's Algorithm</strong> to find the most optimal routes that visitors take, which can be used to predict where congestion or high footfall may occur.</p>

            <h4 onclick="toggleCode('dijkstraCode')">Algorithm: Dijkstra's Algorithm</h4>
            <p><strong>Purpose:</strong> Find the shortest path in terms of travel time or distance from one location to another, helping to predict the flow of visitors between popular spots.</p>
            <p><strong>Concept:</strong> Dijkstra’s algorithm calculates the shortest path from a starting node (tourist spot) to all other nodes (other spots), helping in understanding which routes will see the most visitors. By examining the number of visitors traveling along each route, the algorithm can predict footfall at different locations.</p>
            <p><strong>Implementation:</strong></p>
            <ul>
                <li><strong>Input:</strong> A graph of tourist spots with weighted edges representing the time or distance between spots.</li>
                <li><strong>Output:</strong> Shortest paths from one spot to all others.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <div id="dijkstraCode" class="algorithm-code">
                <pre><code>Areas: Central Plaza → Hilltop Observatory → Lakeview Park.
Result: Dijkstra’s algorithm finds the fastest paths, which can predict that Central Plaza will see heavy traffic because it's connected to several key locations.</code></pre>
            </div>
        </div>

        <div class="algorithm-section">
            <h3>4. Reducing Congestion Using Dynamic Routing</h3>
            <p><strong>Problem:</strong> Popular spots often face traffic congestion, frustrating tourists and locals.</p>
            <p><strong>Solution:</strong> Implement <strong>Bellman-Ford Algorithm</strong> to reroute tourists dynamically.</p>

            <h4 onclick="toggleCode('bellmanFordCode')">Algorithm: Bellman-Ford</h4>
            <p><strong>Purpose:</strong> Identify shortest paths dynamically, even with real-time traffic changes.</p>
            <p><strong>Implementation:</strong></p>
            <ul>
                <li><strong>Input:</strong> Real-time traffic data and travel time updates for roads.</li>
                <li><strong>Output:</strong> Adjusted routes to reduce congestion.</li>
            </ul>
            <p><strong>Example:</strong></p>
            <div id="bellmanFordCode" class="algorithm-code">
                <pre><code>Congestion detected on the main road to Central Plaza.
Result: Tourists rerouted via secondary roads to reach the spot.</code></pre>
            </div>
        </div>

        <div class="algorithm-section">
            <h3>5. Dynamic Pricing for Seasonal Demand</h3>
            <p><strong>Problem:</strong> Tourism revenue can be maximized with dynamic pricing strategies.</p>
            <p><strong>Solution:</strong> Use <strong>Breadth-First Search (BFS)</strong> to identify and price tourist spots based on demand and distance from popular tourist areas.</p>

            <h4 onclick="toggleCode('bfsCode')">Algorithm: Breadth-First Search (BFS)</h4>
            <p><strong>Purpose:</strong> Explore all possible tourist spots by visiting neighboring nodes first, helping to identify which spots are the most connected and, therefore, most likely to experience higher footfall. The algorithm can then be used for dynamic pricing by identifying the spots with the highest demand and adjusting prices accordingly.</p>
            <p><strong>Concept:</strong> BFS explores all tourist spots level by level, starting from the most popular spots and expanding outward. This can be used to identify tourist spots that may see increasing demand as people visit nearby spots.</p>
            <p><strong>Code Example:</strong></p>
            <div id="bfsCode" class="algorithm-code">
                <pre><code>
function bfs(graph, start) {
    let visited = new Set();
    let queue = [start];
    while (queue.length > 0) {
        let current = queue.shift();
        if (!visited.has(current)) {
            visited.add(current);
            console.log(current);
            let neighbors = graph[current] || [];
            for (let neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                    queue.push(neighbor);
                }
            }
        }
    }
}

const touristSpots = {
    "Central Plaza": ["Historic Market", "Lakeview Park"],
    "Lakeview Park": ["Central Plaza", "Hilltop Observatory"],
    "Hilltop Observatory": ["Lakeview Park"],
    "Historic Market": ["Central Plaza"]
};

bfs(touristSpots, "Central Plaza"); // Start BFS from Central Plaza
                </code></pre>
            </div>
        </div>

    </div>

    <div class="content">
        <h2>Conclusion</h2>
        <p>By employing algorithms such as <strong>Merge Sort</strong> for ranking, <strong>Floyd-Warshall</strong> for route optimization, <strong>Dijkstra's Algorithm</strong> for predicting visitor trends, and <strong>Breadth-First Search (BFS)</strong> for dynamic pricing, cities can design smarter tourism systems. These data-driven approaches enhance efficiency, support sustainability, and improve the visitor experience, all while aligning with global goals like <strong>SDG 11.4</strong> to protect and safeguard cultural and natural heritage.</p>
    </div>

    <script>
        function toggleCode(id) {
            var codeElement = document.getElementById(id);
            if (codeElement.style.display === "none" || codeElement.style.display === "") {
                codeElement.style.display = "block";
            } else {
                codeElement.style.display = "none";
            }
        }
    </script>

</body>
</html>

</body>
</html>
