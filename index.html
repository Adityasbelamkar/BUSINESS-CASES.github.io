<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Traffic Management and Disaster Impact</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #eef2f3;
            color: #333;
        }
        h1 {
            color: #ffffff;
            background: #2c3e50;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            margin-top: 50px;
        }
        h2, h3 {
            color: #2c3e50;
        }
        #instructions {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2em;
            background: #d6eaf8;
            padding: 15px;
            border: 1px solid #aed6f1;
            border-radius: 10px;
        }
        #details {
            display: none;
            margin-top: 20px;
        }
        .section {
            background: #ffffff;
            border: 1px solid #d5d8dc;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        ul {
            list-style-type: square;
            margin-left: 20px;
        }
        footer {
            text-align: center;
            margin-top: 20px;
            font-size: 0.9em;
            color: #555;
        }
        pre {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #dcdcdc;
            overflow-x: auto;
        }
    </style>
    <script>
        function toggleDetails(id) {
            const details = document.getElementById(id);
            details.style.display = details.style.display === 'none' ? 'block' : 'none';
        }
    </script>
</head>
<body>
    <div id="instructions">
        <p>Click on the business cases to know about them..</p>
    </div>

    <h1 onclick="toggleDetails('trafficDetails')">Smart Traffic Management System</h1>
    <div id="trafficDetails" style="display: none;">
        <div class="section">
            <h2>Smart Traffic Management Systems</h2>
            <p>Target 11.7: Provide Access to Safe and Inclusive Green and Public Spaces</p>
            <p><strong>Target:</strong> By 2030, provide universal access to safe, inclusive, and accessible, green and public spaces, particularly for women and children, older persons, and persons with disabilities.</p>
        </div>
        <div class="section">
            <h3>Indicators</h3>
            <ul>
                <li><strong>Indicator 11.7.1:</strong> Average share of the built-up area of cities that is open space for public use for all, by sex, age, and persons with disabilities.</li>
                <li><strong>Indicator 11.7.2:</strong> Proportion of persons victimized by physical or sexual harassment, by sex, age, disability status, and place of occurrence, in the previous 12 months.</li>
            </ul>
        </div>
        <div class="section">
            <h3>Examples</h3>
            <p>Smart Traffic Management can include:</p>
            <ul>
                <li>Adaptive traffic signal systems that respond to real-time congestion.</li>
                <li>Integration of green corridors to reduce pollution and enhance public spaces.</li>
                <li>Advanced route planning for emergency and public transport vehicles.</li>
            </ul>
        </div>
        <div class="section">
            <h3>Advantages</h3>
            <ul>
                <li><strong>Cost Efficiency:</strong> Reduces fuel consumption and operational costs by minimizing congestion.</li>
                <li><strong>Improved Traffic Flow:</strong> Decreases bottlenecks and enhances movement across the network.</li>
                <li><strong>Scalability:</strong> Effective in both small and large cities, adapting as urban areas grow.</li>
                <li><strong>Safety:</strong> Enhances road safety and reduces accidents through optimized systems.</li>
            </ul>
        </div>
        <div class="section">
            <h3>Kruskal's Algorithm in Traffic Management</h3>
            <p>The city's traffic network is modeled as a graph, with intersections as nodes and roads as edges. Each edge is weighted based on traffic factors like travel time or congestion.</p>
            <p>Kruskalâ€™s Algorithm is applied to find the Minimum Spanning Tree (MST) of the traffic network, connecting all key intersections with the minimum total weight (e.g., minimal congestion or travel time).</p>
            <p>By selecting the least costly paths (in terms of time or congestion), Kruskal's algorithm ensures optimal routing and traffic flow across the city.</p>
        </div>
        <div class="section">
            <h3>Kruskal's Code</h3>
            <h4 onclick="toggleDetails('kruskalCode')" style="cursor: pointer; color: #007bff;">Click to view Kruskal's Algorithm Implementation</h4>
            <div id="kruskalCode" style="display: none;">
                <pre>
#include <bits/stdc++.h>
using namespace std;

class Kruskal {
public:
    struct Edge {
        int u, v, w;
    };

    int n, m, count = 0;
    vector<Edge> edges, ans;
    int* arr;

    Kruskal() {
        cout << "Enter number of vertices: ";
        cin >> n;
        cout << "Enter number of edges in the graph:";
        cin >> m;

        edges.resize(m);
        cout << "Enter values for u, v, w one by one:\n";
        for (int i = 0; i < m; i++) {
            cin >> edges[i].u >> edges[i].v >> edges[i].w;
        }

        mergeSort(edges);

        arr = (int*)malloc(sizeof(int) * n);
        for (int i = 0; i < n; i++) {
            arr[i] = i;
        }
    }

    void merge(vector<Edge>& left, vector<Edge>& right, vector<Edge>& result) {
        int i = 0, j = 0, k = 0, p = left.size(), q = right.size();
        while (i < p && j < q) {
            if (left[i].w <= right[j].w) {
                result[k++] = left[i++];
            } else {
                result[k++] = right[j++];
            }
        }
        while (i < p) result[k++] = left[i++];
        while (j < q) result[k++] = right[j++];
    }

    void mergeSort(vector<Edge>& edges) {
        int n = edges.size();
        if (n > 1) {
            vector<Edge> left(edges.begin(), edges.begin() + n / 2);
            vector<Edge> right(edges.begin() + n / 2, edges.end());
            mergeSort(left);
            mergeSort(right);
            merge(left, right, edges);
        }
    }

    void Union(int u, int v) {
        int temp = arr[u];
        for (int i = 0; i < n; i++) {
            if (arr[i] == temp)
                arr[i] = arr[v];
        }
    }

    bool Find(int u, int v) {
        if (arr[u] == arr[v])
        return 1;
        else
            return 0;
    }

    void spanning_tree() {
        int i = 0;
        while (count< n - 1 && i < m) {
            if (Find(edges[i].u, edges[i].v)==0) {
                Union(edges[i].u, edges[i].v);
                ans.push_back(edges[i]);
                count++;
            }
            i++;
        }
    }
};

int main() {
    Kruskal k;
    k.spanning_tree();

    cout << "Edges in the Minimum Spanning Tree:\n";
    for (size_t i = 0; i < k.ans.size(); i++) {
    cout << k.ans[i].u << " " << k.ans[i].v << " " << k.ans[i].w << endl;
}

    return 0;
}
                </pre>
            </div>
        </div>
    </div>

    <h1 onclick="toggleDetails('disasterDetails')">Impact of Natural Disasters</h1>
    <div id="disasterDetails" style="display: none;">
        <div class="section">
            <h2>Target 11.5</h2>
            <p>Significantly reduce the number of deaths and people affected by disasters, with a focus on protecting the poor and vulnerable.</p>
        </div>
        <div class="section">
            <h3>Indicators</h3>
            <ul>
                <li><strong>Indicator 11.5.1:</strong> Number of deaths, missing persons, and directly affected persons attributed to disasters per 100,000 population.</li>
                <li><strong>Indicator 11.5.2:</strong> Direct economic loss attributed to disasters in relation to global domestic product (GDP).</li>
            </ul>
        </div>
        <div class="section">
            <h3>Examples</h3>
            <p>Efforts to reduce the impact of natural disasters include:</p>
            <ul>
                <li>Early warning systems for severe weather events.</li>
                <li>Community-based disaster preparedness programs.</li>
                <li>Infrastructure designed to withstand natural calamities.</li>
            </ul>
        </div>
        <div class="section">
            <h3>Advantages</h3>
            <ul>
                <li><strong>Lives Saved:</strong> Reduces fatalities and injuries through proactive measures.</li>
                <li><strong>Economic Resilience:</strong> Minimizes economic losses and aids quicker recovery.</li>
                <li><strong>Social Equity:</strong> Protects vulnerable populations, ensuring inclusivity.</li>
                <li><strong>Global Impact:</strong> Contributes to sustainable development by addressing disaster risks.</li>
            </ul>
        </div>
    </div>
        
  <!-- Header -->
    <header>
        <h1>Efficient Management of Tourism</h1>
        <p>Optimizing Resources through Efficient Algorithms</p>
    </header>

    <!-- Content Section -->
    <section>
        <h2>Introduction</h2>
        <p>
            Tourism is a critical driver of economic growth, cultural exchange, and urban development
            in modern cities. By focusing on innovation, sustainability, and inclusivity, cities can design tourism
            systems that not only
            attract visitors but also enrich the lives of residents and support long-term economic growth. Properly
            managing tourism through thoughtful
            city design can transform challenges into opportunities, creating vibrant and thriving urban environments.
        </p>
    </section>
    <section>
        <h3>finding Popular Tourism Spots</h3>
        <p>
            For managing tourism effectively, one of the critical steps is to identify the most popular tourist spots in
            a city.
            suppose there are 8 tourist spots in a city and we need to find the most popular spots based on the number
            of visits they receive.
        </p>
        <p>
            <strong>The below are the tourist places in the city along with visits to them per month:</strong>
        <table class="tourism-table">
            <tr>
                <th>Place</th>
                <th>Visits per Month</th>
                <th>Assigned number</th>
            </tr>
            <tr>
                <td>Shani Deva Temple</td>
                <td>5000</td>
                <td>3</td>
            </tr>
            <tr>
                <td>Sunset Park</td>
                <td>3000</td>
                <td>2</td>
            </tr>
            <tr>
                <td>Summit Mountains</td>
                <td>7000</td>
                <td>1</td>
            </tr>
            <tr>
                <td>City Museum</td>
                <td>1500</td>
                <td>7</td>
            </tr>
            <tr>
                <td>Zoo/Aquarium</td>
                <td>4000</td>
                <td>4</td>
            </tr>
            <tr>
                <td>Forest Area</td>
                <td>6000</td>
                <td>6</td>
            </tr>
            <tr>
                <td>Crystal Lake</td>
                <td>4000</td>
                <td>5</td>
            </tr>
            <tr>
                <td>Historical Site</td>
                <td>500</td>
                <td>8</td>
        </table>
        </p>
        <strong>The below graph represents tourist places in the city:</strong>
        <p>number in nodes represnt the tourist places which are assigned in above table.</p>
        <div class="graph1">
            <img src="files/toursim_graph_00.png" alt="Tourism Graph">
        </div>
        <p class="graph-caption">
            Figure T1: Graph representing tourist spots in the city.
        </p>
        <h4>Solution</h4>
        <p>
            This helps in optimizing resources, planning infrastructure, and prioritizing
            promotional strategies for high-traffic areas. Sorting allows us to identify the spots requiring more
            attention, such as better crowd management.
            hence after we will get more popular spots which are represented in <strong>figure T2</strong>.
        </p>

        <p><strong>We chose merge sort for this task due to its efficiency and stability. Merge sort is a comparison-based sorting algorithm that uses a divide-and-conquer approach. There are several key reasons for choosing merge sort:</strong></p>

        <p><strong>&#9673</strong> Merge sort has a time complexity of O(n log n), making it suitable for sorting large datasets, such as city-wide tourist visit records.</p>

        <p><strong>&#9673</strong> Merge sort is a stable sorting algorithm, meaning it maintains the relative order of equal elements, which can be important for certain datasets.</p>

        <p><strong>&#9673</strong> Merge sort works well with large datasets and can be easily adapted for external sorting, where data is too large to fit into memory.</p>

        <p>
            Here is the implementation of Merge Sort for sorting tourism data in C++. You can view the code using the
            link below:
        </p>
        <a href="">Merge sort Code</a>
        <p>After sorting we get popular spots which are represented in below table and Graph in <strong>Figure T2</strong></p>
    </section>
    <section>
        <h3>Identifying Tourism Spots</h3>
        <p>
            For managing tourism effectively, we need to find the tourism spots in the city.For this we can represent
            tourist locations as nodes in a graph, with edges
            representing travel routes and their respective distances.for example let below 6 tourist places.And assign
            numbers to it.
        <table class="tourism-table">
            <tr>
                <th>Place</th>
                <th>Number</th>
            </tr>
            <tr>
                <td>Shani Deva Temple</td>
                <td>3</td>
            </tr>
            <tr>
                <td>Sunset Park</td>
                <td>2</td>
            </tr>
            <tr>
                <td>Summit Mountains</td>
                <td>1</td>
            </tr>
            <tr>
                <td>Zoo/Aquarium</td>
                <td>4</td>
            </tr>
            <tr>
                <td>Forest Area</td>
                <td>6</td>
            </tr>
            <tr>
                <td>Crystal Lake</td>
                <td>5</td>
            </tr>
        </table>
        </p>
        <strong>The below graph represents tourist places in the city:</strong>
        <p>number in nodes represnt the tourist places which are assigned in above table.</p>
        <div class="graph1">
            <img src="files/Tourism_graph.png" alt="Tourism Graph">
        </div>
        <p class="graph-caption">
            Figure T2: Graph representing tourist spots in the city with distances between them
        </p>
        <p>
            Using breadth First Search (BFS), we traverse the graph to identify all accessible tourist spots starting
            from a chosen node.
        </p>
        <p>
            Here is the implementation of breadth first search tourism data in C++. You can view the code using the
            link below:
        </p>
        <a href="">breadth first search</a>

        <p>We chose Breadth-First Search (BFS) for this task because of its suitability for graph traversal and
            searching in scenarios
            like identifying tourist spots and exploring connectivity. BFS ensures a systematic exploration of the graph
            level by level, making it an excellent choice for analyzing tourist data</p>

        <p><strong>&#9673</strong> BFS is ideal for solving problems like identifying all connected tourist spots or
            determining if a route exists between two places, which directly aligns with real-world tourism management
            tasks.</p>

        <p><strong>&#9673</strong> With a time complexity of O(V + E) (where
            V is the number of vertices and
            E is the number of edges), BFS is efficient for graphs like city maps</p>

    </section>

    <section>
        <h3>Finding Shortest Paths Between All Tourist Spots</h3>
        <p>
            After identifying popular tourist spots, the next important step is to provide tourists with efficient ways
            to navigate between them. Tourists often want to visit multiple locations during their trip, and knowing the
            shortest paths between these
            locations can significantly enhance their experience. This requires finding the shortest paths between all
            pairs of tourist spots.Consider graph represented in <strong>figure T1</strong>.
        </p>
        <p>
            <strong>The below are the tourist places in the city along with distances between them:</strong>
        <ul>
            <li>Summit Mountains â†’ Sunset Park (80), Shani Deva Temple (40)</li>
            <li>Sunset Park â†’ Shani Deva Temple (110), Crystal Lake (60)</li>
            <li>Shani Deva Temple â†’ Zoo/Aquarium (20), Crystal Lake (40)</li>
            <li>Zoo/Aquarium â†’ Forest Area (30)</li>
            <li>Crystal Lake â†’ Forest Area (40)</li>
            <li>Forest Area â†’ Summit Mountains (40)</li>
        </ul>
        </p>
        <h4>Solution</h4>
        <p>
            The Floyd-Warshall algorithm is an excellent choice for finding the shortest paths between all pairs of
            vertices in a weighted graph. In our case, the vertices represent tourist spots, and the edge weights
            represent the distances or travel times between them.
            By applying the Floyd-Warshall algorithm, we can generate a matrix that provides the shortest path between
            any two tourist spots.
        </p>
        <p><strong>Why Floyd-Warshall?</strong></p>

        <p><strong>&#9673</strong> While Dijkstra's algorithm finds the shortest paths from a single source vertex to
            all other vertices,
            Floyd's algorithm computes the shortest path between every pair of nodes. Since we are interested in the
            shortest paths between all tourist spots, this algorithm is a natural fit.
        </p>

        <p><strong>&#9673</strong> Floyd's algorithm works on both directed and undirected graphs</p>

        <p><strong>&#9673</strong> Floydâ€™s algorithm is stable, meaning it will give consistent results even if multiple
            paths exist between the same pair of nodes.</p>

        <p></p>

        <p>
            Here is the implementation of floyd' algorithm to find out minimum distance between all tourism spots in
            C++. You can view the code using the
            link below:
        </p>
        <a href="">floyd graph code</a>
    </section>
    <section>
        <h3>Personalized Recommendations Based on Tourist Interests</h3>
        <p>
            Tourists have diverse interests, encompassing historical sites, museums, outdoor activities, culinary
            experiences, cultural events, and more. A well-designed recommendation system can analyze tourist profiles
            and preferences to suggest relevant attractions, activities, and experiences, making their trip more
            enjoyable and fulfilling.
        </p>
        <h4>Solution</h4>
        <p>
            A recommendation system can be implemented to offer personalized suggestions. We will focus on a
            content-based filtering approach, which recommends items similar to what a user has liked in the past.
        </p>

        <p><strong>&#9673</strong> Recommendations are based on the similarity between the tourist's past preferences
            and the content of the attractions. This makes the recommendations easy to understand and justify.</p>

            <p>
                Here is the implementation of reccomendation engine for suggesting tourism spots in C++. You can view the
                code using the
                link below:
            </p>
            <a href="">reccomendation engine code</a>

        <p>For creating reccomendation system we can do this by suggesting similar type of tourism spots for i have created a text file to store tourism data</p>
        <p><strong>Here is the text file</strong> 
            <a href="" class="file1">Toursist_data_file</a></p>
        <p>in that file first column represents location we are searching and second names represents suggestions with most number of searches</p>
    </section>
    <section>
        <h3>Analyzing Tourist Patterns</h3>
        <p>
            Tourist destinations often experience fluctuating crowd levels based on the time of day, season, or specific
            events. Efficiently analyzing
            these patterns is essential to enhance the tourist experience and optimize resource allocation at tourist
            spots.
        </p>
        <p>
            key challanges are Quickly determining the total crowd in a specific time or location range (e.g.,in a specific section of a park).

            Frequent Updates:
            The dataset needs dynamic updates to account for new data (e.g., arrival or departure of tourists).
        </p>
        <p><strong>Visitor Distribution Across Zones:</strong></p>
        <table class="tourism-table">
            <tr>
                <th>Zone</th>
                <th>Visitors</th>
            </tr>
            <tr>
                <td>Zone 1</td>
                <td>50</td>
            </tr>
            <tr>
                <td>Zone 2</td>
                <td>20</td>
            </tr>
            <tr>
                <td>Zone 3</td>
                <td>30</td>
            </tr>
            <tr>
                <td>Zone 4</td>
                <td>40</td>
            </tr>
            <tr>
                <td>Zone 5</td>
                <td>10</td>
            </tr>
            <tr>
                <td>Zone 6</td>
                <td>60</td>
            </tr>
        </table>
        <p>In any one of the above tourist may increase or decrese(for eg: in zone zone 3 visitors nay icrease to 55 which is shown in code)</p>
        <h4>Solution</h4>
        <p>
            Segment trees provide an efficient way to handle range-based problems dynamically. They enable fast querying
            and updating operations, making them a perfect choice for this use case.
        </p>
        <p><strong>Why segment trees?</strong></p>

        <p><strong>&#9673</strong>
            They allow quick computation of aggregate data (e.g., total crowd over a range) in O(logn) time.
        </p>

        <p><strong>&#9673</strong> Dynamic changes in data (e.g., adding new visitors) can be handled to
            large datasets, making them suitable for managing data over extended time periods or across multiple
            locations.</p>


        <p>
            Here is the implementation of segment trees for tourism spots in C++. You can view the code using the
            link below:
        </p>
        <a href="" download>Segement tree code</a>
    </section>
    

    <footer>
        <p><strong>Smart Solutions | Powered by Innovation and Preparedness</strong></p>
    </footer>
</body>
</html>
